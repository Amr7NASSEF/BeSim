function [diagnostics, con, obj, optimize_con_info] = BeMPC_DualCheck(outdata, model)
% verification of the dual variables indexing of the original MPC 
% problem generated by BeMPCdesign

%     TODO: for loop over N-steps

 %% MPC variables and weights

    % dimensions
    nx = model.pred.nx;
    ny = model.pred.ny;
    nd = model.pred.nd;
    nu = model.pred.nu;

    % horizons   
    N = outdata.ctrl.MPC.N;   %  prediction horizon
    Nc = outdata.ctrl.MPC.Nc; %  control horizon
    Nrp = outdata.ctrl.MPC.Nrp; % reference preview horizon
    Ndp = outdata.ctrl.MPC.Ndp; % disturbacne preview horizon

    % variables
    x = sdpvar(nx, N+1, 'full'); % states of the building
    u = sdpvar(nu, Nc, 'full'); % ctrl action - heat commanded by the thermostat [W]
    y = sdpvar(ny, N, 'full'); % output = indoor temperatures [degC]
    s = sdpvar(ny, N, 'full'); %  general slack

    % weight diagonal matrices 
    Qsb = outdata.ctrl.MPC.Qsb;
    Qsa = outdata.ctrl.MPC.Qsa;
    Qu = outdata.ctrl.MPC.Qu;

    
%% MPC data from simiulations

    % disturbances with preview
    d_prev = outdata.data.D; 
    % above and below threshold -- dynamic comfort zone 
    wa_prev = outdata.data.wa;
    wb_prev = outdata.data.wb;
    % variable energy price profile
    price = outdata.data.Price;
    x0 = outdata.data.Xe(:,1);
    %  initial conditions
    x(:, 1) = x0;
    
    %% MPC problem formulation
    %  objective function+ constraints init
    obj = 0;
    con = [];
    
    AB = zeros( nx , N*nu );
    AE = zeros( nx , N*nd );
    AG = zeros( nx, N*1);
    AExpX0 = eye(nx) * x(:,1);
  
    for k = 1:N   
    %   -------------  Constraints  -------------         
        % disturbances preview
        if k > Ndp
            Dpreview = d_prev(:, Ndp);
        else
            Dpreview = d_prev(:, k);
        end

        % comfort zone and price preview 
        if k > Nrp
            wa = wa_prev(:,Nrp);
            wb = wb_prev(:,Nrp);
            P = price(:,Nrp);
        else
            wa = wa_prev(:,k);
            wb = wb_prev(:,k);
            P = price(:,k);
        end

        % move blocking
        if k > Nc
            uk = u(:,Nc);
%             u_traj(:,k) = u(:,Nc);
        else
            uk = u(:,k);
%             u_traj(:,k) = u(:,k);
        end

        %  state and output update equations
        if outdata.ctrl.MPC.Condensing    %  Single shooting
            if k == 1
                AB(:, (N-k)*nu+1:(N-k+1)*nu ) = model.pred.Bd;        %  input matrix evolution
                AE(:, (N-k)*nd+1:(N-k+1)*nd ) =  model.pred.Ed;       %  disturbance matrix evolution
                AG(:, (N-k)*1+1:(N-k+1)*1 ) =  model.pred.Gd;         %  initial conditions matrix evolution
                con = con + [ (y(:, k) == model.pred.Cd*x(:, k) + model.pred.Dd*uk + model.pred.Fd*1):['SSM_single_shoot_k=',int2str(k)] ];
            else
                AExpX0 = model.pred.Ad * AExpX0;
                con = con + [ (y(:, k) == model.pred.Cd*( AExpX0 + AB(:, (N-k+1)*nu+1 : end ) * reshape( u(:,1:k-1) , nu * (k-1) , 1) + ...
                                                                 AE(:, (N-k+1)*nd+1 : end ) * reshape( d_prev(:,1:k-1) , nd * (k-1) , 1) + ...
                                                                 AG(:, (N-k+1)*1+1 : end ) * ones(k-1,1) ) + ...
                                                                 model.pred.Dd*uk  + model.pred.Fd*1):['SSM_single_shoot_k=',int2str(k)] ];

                AB(:, (N-k)*nu+1:(N-k+1)*nu ) = model.pred.Ad* AB(:, (N-k+1)*nu+1:(N-k+2)*nu );
                AE(:, (N-k)*nd+1:(N-k+1)*nd ) = model.pred.Ad* AE(:, (N-k+1)*nd+1:(N-k+2)*nd );
                AG(:, (N-k)*1+1:(N-k+1)*1 ) = model.pred.Ad* AG(:, (N-k+1)*1+1:(N-k+2)*1 );
            end  
        else    %  Multiple shooting
            if nd == 0 % no disturbances formulation
                con = con + [ (x(:, k+1) == model.pred.Ad*x(:, k) + model.pred.Bd*uk + model.pred.Gd*1):['SSM_multiple_shoot_states_k=',int2str(k)] ];
                con = con + [ (y(:, k) == model.pred.Cd*x(:, k)  + model.pred.Dd*uk + model.pred.Fd*1):['SSM_multiple_shoot_outputs_k=',int2str(k)] ];
            else
                con = con + [ (x(:, k+1) == model.pred.Ad*x(:, k) + model.pred.Bd*uk + ...
                    model.pred.Ed*Dpreview + model.pred.Gd*1):['SSM_multiple_shoot_states_k=',int2str(k)]];
                con = con + [ (y(:, k) == model.pred.Cd*x(:, k)  + model.pred.Dd*uk + model.pred.Fd*1):['SSM_multiple_shoot_outputs_k=',int2str(k)] ];
            end
        end

        %         % comfort zone with  violation penalty - dynamic comfort zone
            con = con + [ (wb-s(:,k)<= y(:,k) <=wa+s(:,k)):['y_zone_k=',int2str(k)] ];
            %   input constraints
            con = con + [ (model.pred.umin <= uk <= model.pred.umax):['u_box_k=',int2str(k)] ];
        % %       slack constraints 
         con = con + [ (0*ones(model.pred.ny,1)<=s(:,k)):['nonnegative_slacks_k=',int2str(k)] ];

    %   -------------  OBJECTIVE FUNCTION  -------------
        %    % quadratic objective function withouth states constr.  penalisation
                obj = obj + s(:,k)'*Qsb*s(:,k) + ...         %  comfort zone penalization
                              P*(uk'*Qu*uk);                              %  quadratic penalization of ctrl action move blocking formulation
    end


     %% construction of object optimizer
     %   structure:  optimizer(constraints, objecttive, options, input_params, output_params)

    %  optimizer options
    try
        options = sdpsettings('verbose', 1, 'solver','gurobi','gurobi.TimeLimit',5);
        test = optimizer([],[],options,[],[]);
        % options = sdpsettings('verbose', 1, 'warning', 1, 'beeponproblem', 1, 'solver','cplex');
    catch
        options = sdpsettings('verbose', 1, 'solver','quadprog', 'savesolveroutput', 1);
    end
    
% %     original optimizer 
%     mpc = optimizer(con, obj, options,  { x(:, 1), d_prev, wa_prev, wb_prev, price }, {u(:,1); obj} );
    
    diagnostics = optimize(con,obj,options);
    
    
%% Duals analysis

    for k = 1:length(con) 
        optimize_con_info.i_length(k) = length(double(con(k))); 
        optimize_con_info.duals{k} = dual(con(k))';
        optimize_con_info.Tags{k} = tag(con(k));  
        optimize_con_info.class(k) = constraintclass(con(k));
        if optimize_con_info.class(k) == 3  % equality constraints class
           index{k} = zeros(1,length(double(con(k))));
        else  % inequality constrints
           index{k} = ones(1,length(double(con(k))));
        end  
    end     
    DUALS = cell2mat(optimize_con_info.duals);
    INDEX =  cell2mat(index);

        %  dimensions
    optimize_con_info.con_nr = sum(optimize_con_info.i_length);
    optimize_con_info.eq_nr = sum(~INDEX);
    optimize_con_info.ineq_nr = sum(INDEX);
    
    
%     optimize_con_info.TAGS = cell(optimize_con_info.con_nr,1);
%     for k = 1:length(con) 
%        optimize_con_info.TAGS(sum(optimize_con_info.i_length(1:k-1))+1:sum(optimize_con_info.i_length(1:k))) = cell(optimize_con_info.Tags{k})
%     end

if false
%     plot duals
    figure; 
    subplot(2,2,1)
    bar(DUALS)
    title('DUALS optimize - as defined')
    subplot(2,2,2)
    orderDUALS = [DUALS(INDEX ==0) DUALS(INDEX ==1)];
    bar(orderDUALS)
    title('DUALS optimize - ordered')
    subplot(2,2,3)
    bar(outdata.solver.DUALS(:,1)')
    hold on
    bar([outdata.solver.EQLIN(:,1); outdata.solver.INEQLIN(:,1)])
    title('DUALS optimizer - ordered')
    subplot(2,2,4)
    ResiDUALS = orderDUALS - outdata.solver.DUALS(:,1)';
    bar(ResiDUALS)
    title('ResiDUALS - ordered') 
end

    % INDEXING of the ORIGINAL CONSTRAINTS via OPTIMIZE
    optimize_con_info.INDEX = INDEX;  % defines constraints flags 1 = inequality and = 0 equality  

    % INDEXING of the ORDERED CONSTRAINTS via OPTIMIZER
    % we can reconstruct the original mapping via eqINDEX and ineqINDEX 
    optimize_con_info.eqINDEX = find(INDEX);
    optimize_con_info.ineqINDEX = find(~INDEX);   
    % % Because the Optimizer constraints are ordered as: [Equality; Inequality]
    % % Hence we can take the first 1:eq_nr elements and apply ordering eqINDEX
    % % And then take the eq_nr+1:ineq_nr elements and apply ordering ineqINDEX

    % %   verify:
    %     figure; 
    %     bar([outdata.solver.EQLIN(:,1); outdata.solver.INEQLIN(:,1)])  




end